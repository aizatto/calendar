{"version":3,"sources":["styles/styles.module.scss","contexts/GoogleContext.tsx","components/Conference.tsx","List.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","GoogleContext","React","createContext","authenticated","ConferenceComponent","props","url","event","hangoutLink","conferenceData","entry","entryPoints","find","entryPointType","uri","conference","style","textDecoration","message","summary","description","join","href","Group","icon","onClick","copy","RangePicker","DatePicker","day","Date","Attendees","attendees","length","sort","a","b","displayName","email","localeCompare","declined","filter","attendee","responseStatus","attendeesElement","map","name","key","id","title","DateTime","start","dateTime","end","startDateTime","endDateTime","dateFns","Intervals","elements","intervals","interval","seconds","getTime","isPast","className","undefined","toISOString","IntervalTime","IntervalBlock","remainingIntervals","remaining","aizattoDateFns","remainingElement","time","hours","Math","floor","minutes","push","Event","useState","status","findIndex","self","collapsed","setCollapsed","htmlLink","cursor","hangoutButton","locationElement","location","styles","dangerouslySetInnerHTML","__html","CalendarAuthenticated","timeMin","setTimeMin","timeMax","setTimeMax","events","setEvents","useEffect","async","gapi","client","calendar","list","calendarId","maxResults","orderBy","singleEvents","result","items","eventsFiltered","date","eventsGroupBy","Map","forEach","startDate","endDate","get","has","set","days","Array","from","dateStr","busyIntervals","freeIntervals","eventsElements","paddingBottom","Fragment","defaultValue","moment","onChange","dates","toDate","Calendar","Consumer","Content","Layout","App","setAuthenticated","script","document","createElement","src","defer","initClient","discoveryDocs","scope","init","apiKey","process","REACT_APP_GOOGLE_APP_ID","clientId","GoogleAuth","auth2","getAuthInstance","isSignedIn","listen","signedIn","googleUser","currentUser","onload","load","firstScript","getElementsByTagName","parentNode","insertBefore","Provider","value","background","signOut","signIn","prompt","Boolean","window","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.811676b1.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"description\":\"styles_description__-yQ6f\"};","import React from 'react';\n\nexport const GoogleContext = React.createContext({\n  authenticated: false,\n  // IsSignedInListener: (signedIn: boolean): void => {},\n});","import React from 'react';\nimport copy from 'copy-to-clipboard';\nimport { Button } from 'antd';\n\ninterface ConferenceData {\n  entryPoints: {\n    entryPointType: string,\n    uri: string,\n    label: string,\n    meetingCode: string,\n    password: string,\n  }[]\n}\n\nexport function conference(event: gapi.client.calendar.Event) {\n  if (event.hangoutLink) {\n    return event.hangoutLink;\n  }\n\n  // @ts-ignore\n  const conferenceData: ConferenceData = event.conferenceData;\n  if (!conferenceData) {\n    return;\n  }\n\n  const entry = conferenceData.entryPoints.find(entry => entry.entryPointType === 'video');\n  return entry?.uri;\n}\n\nexport const ConferenceComponent: React.FC<{event: gapi.client.calendar.Event}> = (props) => {\n  const url = conference(props.event);\n\n  if (!url) {\n    return <span style={{textDecoration: 'line-through'}}>Video Call</span>;\n  }\n\n  const { event } = props;\n\n  const message = [\n    `@here ${event.summary}`,\n    url,\n    event.description,\n  ].join(\"\\n\\n\");\n\n  return (\n    <span>\n      Video Call:\n      {' '}\n      <a href={url}>\n        {url}\n      </a>\n\n      <Button.Group>\n        <Button icon=\"video-camera\" href={url}>\n          Video Call\n        </Button>\n        <Button icon=\"copy\" href={url} onClick={() => copy(url)}>\n          Copy URL\n        </Button>\n        <Button icon=\"copy\" onClick={() => copy(message)}>\n          Copy as Message\n        </Button>\n      </Button.Group>\n    </span>\n  )\n}","import React, { useState, useEffect } from 'react';\nimport { GoogleContext } from './contexts/GoogleContext';\nimport * as dateFns from 'date-fns';\nimport * as aizattoDateFns from '@aizatto/date-fns';\nimport styles from './styles/styles.module.scss';\nimport { DatePicker } from 'antd';\nimport moment from 'moment';\nimport { ConferenceComponent } from './components/Conference';\n\nconst { RangePicker } = DatePicker;\n\nconst day = new Date();\n// const defaultTimeMin = dateFns.startOfDay(day);\n// const defaultTimeMax = dateFns.endOfDay(dateFns.addDays(day, 5));\n\nconst Attendees: React.FC<{event: gapi.client.calendar.Event}> = (props) => {\n  const event = props.event;\n\n  if (!event.attendees || !event.attendees.length) {\n    return <></>;\n  }\n\n  const attendees = event.attendees.sort((a, b) => {\n    if (a.displayName && !b.displayName) {\n      return 1;\n    } else if (!a.displayName && b.displayName) {\n      return -1;\n    }\n\n    return a.email.localeCompare(b.email);\n  });\n\n  const declined = attendees.filter(attendee => attendee.responseStatus === \"declined\");\n\n  const attendeesElement = attendees.map(attendee =>  {\n    const style = attendee.responseStatus === \"declined\"\n      ? {textDecoration: \"line-through\"}  \n      : {};\n\n    const name = attendee.displayName ? attendee.displayName : attendee.email;\n\n    return (\n      <li\n        key={`${event.id}:${attendee.email}`}\n        style={style}\n        title={`${name}: ${attendee.responseStatus}`}>\n        {name}\n      </li>\n    );\n  });\n\n  return (\n    <>\n      Attendees: {attendees.length - declined.length}/{attendees.length}\n      <ol>\n        {attendeesElement}\n      </ol>\n    </>\n  );\n}\n\nconst DateTime: React.FC<{event: gapi.client.calendar.Event}> = (props) => {\n  const event = props.event;\n  if (!event.start.dateTime ||\n      !event.end.dateTime) {\n    return <></>\n  }\n\n  const startDateTime =  new Date(event.start.dateTime);\n  const endDateTime = new Date(event.end.dateTime);\n\n  return (\n    <span title={`${event.start.dateTime} - ${event.end.dateTime}`}>\n      {dateFns.format(startDateTime, 'HH:mm')}\n      {' - '}\n      {dateFns.format(endDateTime, 'HH:mm')}\n    </span>\n  );\n}\n\nconst Intervals: React.FC<{intervals: {start: Date, end: Date}[]}> = (props) => {\n  const elements = props.intervals.map(interval => {\n    const seconds = (interval.end.getTime() - interval.start.getTime()) / 1000;\n\n    const isPast = dateFns.isPast(interval.end);\n\n    const style = isPast\n      ? {textDecoration: \"line-through\"}  \n      : {};\n\n    const className = isPast\n      ? 'text-muted'\n      : undefined;\n\n    return (\n      <li key={interval.start.toISOString()} className={className} style={style}>\n        {dateFns.format(interval.start, 'HH:mm')} - {dateFns.format(interval.end, 'HH:mm')}\n        {': '}\n        {IntervalTime(seconds)}\n      </li>\n    )\n  });\n\n  return (\n    <ol>\n      {elements}\n    </ol>\n  )\n}\n\nconst IntervalBlock: React.FC<{intervals: { start: Date, end: Date }[]}> = (props) => {\n  const intervals = props.intervals;\n  const remainingIntervals = intervals.filter(interval => dateFns.isFuture(interval.end));\n  const remaining = aizattoDateFns.intervalsTotal(remainingIntervals);\n\n  let remainingElement: any = IntervalTime(remaining / 1000);\n\n  if (remainingIntervals.length !== intervals.length){\n    remainingElement = <span className=\"text-muted\">{remainingElement}</span>;\n  }\n\n  const time = remainingElement.length !== 0\n    ?\n      <>\n        {remainingElement}\n        {' / '}\n        {IntervalTime(aizattoDateFns.intervalsTotal(intervals) / 1000)}\n      </>\n    : null;\n\n  return (\n    <>\n    {' '}\n    {time}\n    <Intervals intervals={intervals} />\n    </>\n  );\n}\n\nconst IntervalTime = (seconds: number) => {\n  const hours = Math.floor(seconds / (60 * 60));\n  const minutes = Math.floor(seconds / 60) % 60;\n\n  let time = [];\n\n  if (hours > 1) {\n    time.push(`${hours} hours`)\n  } else if (hours === 1) {\n    time.push(`${hours} hour`)\n  }\n\n  if (minutes > 1) {\n    time.push(`${minutes} minutes`)\n  } else if (minutes === 1) {\n    time.push(`${minutes} minute`)\n  }\n\n  return time.join(' ');\n}\n\nconst Event: React.FC<{event: gapi.client.calendar.Event}> = (props) => {\n  const event = props.event;\n  const [collapsed, setCollapsed] = useState(() => {\n    if (event.status === \"cancelled\") {\n      return true;\n    }\n\n    // @ts-ignore\n    if (dateFns.isPast(new Date(event.end.dateTime))) {\n      return true;\n    }\n\n    return event.attendees?.findIndex(attendee => attendee.self && attendee.responseStatus === \"declined\") !== -1;\n  });\n\n\n  const summary = \n    <>\n      <DateTime event={event} />\n      {' '}\n      <a href={event.htmlLink}>{event.summary}</a>\n    </>;\n\n  if (collapsed) {\n    return (\n      <>\n        <span style={{textDecoration: \"line-through\"}}>\n          {summary}\n        </span>\n        {' '}\n        &middot;\n        {' '}\n        <span className=\"text-muted\" style={{cursor: 'pointer'}} onClick={() => setCollapsed(false)}>\n          Show Details\n        </span>\n      </>\n    )\n  }\n\n  const hangoutButton = <ConferenceComponent event={event} />;\n\n  const locationElement = event.location\n    ? <div>{event.location}</div>\n    : null;\n\n  return (\n    <>\n      <div>\n        {summary}\n      </div>\n      {locationElement}\n\n      <Attendees event={event} />\n\n      <div className={styles.description} dangerouslySetInnerHTML={{__html: event.description}} />\n\n      {hangoutButton}\n    </>\n  );\n}\n\n// const CalendarList: React.FC<{calendars: gapi.client.calendar.CalendarListEntry[]}> = (props) => {\n//   const elements = props.calendars.map((calendar) => {\n//     return (\n//       <li key={calendar.id}>\n//       </li>\n//     )\n//   })\n\n//   return (\n//     <>\n//       <ol>\n//         {elements}\n//       </ol>\n//     </>\n//   );\n// }\n\nexport const CalendarAuthenticated: React.FC = (props) => {\n  const [timeMin, setTimeMin] = useState(() => dateFns.startOfDay(day));\n  const [timeMax, setTimeMax] = useState(() => dateFns.endOfDay(dateFns.addDays(day, 5)));\n\n  // const [calendars, setCalendars] = useState<gapi.client.calendar.CalendarListEntry[]>([]);\n  const [events, setEvents] = useState<gapi.client.calendar.Event[]>([]);\n  useEffect(() => {\n    (async () => {\n      const events = await gapi.client.calendar.events.list({\n        calendarId: 'primary',\n        timeMin: timeMin.toISOString(),\n        timeMax: timeMax.toISOString(),\n        maxResults: 100, \n        orderBy: 'startTime',\n        singleEvents: true,\n      });\n      setEvents(events.result.items);\n\n      // const calendars = await gapi.client.calendar.calendarList.list();\n      // setCalendars(calendars.result.items);\n    })();\n  }, [timeMin, timeMax]);\n\n  const eventsFiltered = events.filter(\n    (event) => {\n      // if (event.status === 'cancelled') {\n      //   return false;\n      // }\n      if (event.end.date) {\n        const endDateTime = dateFns.endOfDay(new Date(event.end.date));\n        return dateFns.isAfter(endDateTime, timeMin);\n      }\n      \n      if (event.end.dateTime &&\n          dateFns.isBefore(new Date(event.end.dateTime), timeMin)) {\n        return false;\n      }\n\n      return true;\n    }\n  );\n\n  /**\n   * lodash.groupBy doesn't work for multi day events\n   */\n  const eventsGroupBy = new Map<string, gapi.client.calendar.Event[]>();\n  // const eventsGroupBy = lodash.groupBy(\n  eventsFiltered.forEach(\n    (event) => {\n      const start = event.start.date ?? event.start.dateTime;\n      const end = event.end.date ?? event.end.dateTime;\n\n      if (!start || !end) {\n        return;\n      }\n\n      const startDate = new Date(start);\n      const endDate = new Date(end);\n      const dates = dateFns.eachDayOfInterval({\n        start: startDate,\n        end: endDate,\n      });\n\n      dates.forEach(date => {\n        const key = date.toISOString();\n        const events = eventsGroupBy.get(key) ?? [];\n        events.push(event);\n        if (!eventsGroupBy.has(key)) {\n          eventsGroupBy.set(key, events);\n        }\n      })\n    });\n  \n  const days = Array.from(eventsGroupBy).map(([dateStr, events]) => {\n    const date = new Date(dateStr);\n    const intervals = events.filter(event => {\n      if (event.status === 'cancelled') {\n        return false;\n      }\n\n      if (!event.start.dateTime || !event.end.dateTime) {\n        return false;\n      }\n\n      return event.attendees?.findIndex(attendee => attendee.self && attendee.responseStatus === \"declined\") === -1;\n    }).map(event => {\n      return {\n        // @ts-ignore\n        start: new Date(event.start.dateTime),\n        // @ts-ignore\n        end: new Date(event.end.dateTime),\n      }\n    });\n\n    const busyIntervals = aizattoDateFns.mergeIntervals(intervals);\n    const freeIntervals = aizattoDateFns.oppositeIntervals(\n      {\n        start: dateFns.startOfDay(date),\n        end: dateFns.endOfDay(date),\n      },\n      busyIntervals,\n    );\n\n    const eventsElements = events.map(event => {\n      return (\n        <li key={event.id} style={{paddingBottom: '1rem'}}>\n          <Event event={event} />\n        </li>\n      );\n    });\n\n    return (\n      <React.Fragment key={dateStr}>\n        <h5>{dateFns.format(date, 'EEEE yyyy-MM-dd')}</h5>\n\n        Busy: \n        <IntervalBlock intervals={busyIntervals} />\n\n        Free: \n        <IntervalBlock intervals={freeIntervals} />\n\n        Schedule: {eventsElements.length} {eventsElements.length > 1 ? 'events' : 'event'}\n        <ol>\n          {eventsElements}\n        </ol>\n      </React.Fragment>\n    );\n  });\n\n  return (\n    <>\n      <a href=\"https://calendar.google.com/\">Google Calendar</a>\n      <div>\n        <RangePicker\n          defaultValue={[moment(timeMin), moment(timeMax)]}\n          onChange={(dates) => {\n            setTimeMin(dates[0]!.toDate());\n            setTimeMax(dates[1]!.toDate());\n          }}\n        />\n      </div>\n      {days}\n    </>\n  )\n}\n\nexport const Calendar: React.FC = (props) => {\n  return (\n    <>\n      <GoogleContext.Consumer>\n        {({authenticated}) => (\n          authenticated \n            ? <CalendarAuthenticated />\n            : <>Not Authenticated</>\n        )}\n      </GoogleContext.Consumer>\n    </>\n  )\n}","import React, { useState, useEffect } from 'react';\nimport './App.css';\nimport { GoogleContext } from './contexts/GoogleContext';\nimport { Calendar } from './List';\n\nimport { Button, Layout } from 'antd';\nconst { Content } = Layout;\n\nconst App: React.FC = () => {\n  const [authenticated, setAuthenticated] = useState(false);\n\n  useEffect(() => {\n    const script = document.createElement('script');\n    script.src = 'https://apis.google.com/js/api.js';\n    script.async = true;\n    script.defer = true;\n\n    const initClient = async () => {\n      const discoveryDocs = [\n        // https://developers.google.com/calendar/quickstart/js\n        \"https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest\"\n      ];\n      const scope = [\n        'https://www.googleapis.com/auth/calendar.events.readonly',\n        'https://www.googleapis.com/auth/calendar.readonly',\n      ].join(' ');\n      await gapi.client.init({\n        discoveryDocs,\n        scope,\n        apiKey: process.env.REACT_APP_GOOGLE_APP_ID,\n        clientId: process.env.REACT_APP_GOOGLE_CLIENT_ID,\n      });\n\n      const GoogleAuth = gapi.auth2.getAuthInstance();\n      GoogleAuth.isSignedIn.listen((signedIn) => {\n        setAuthenticated(signedIn);\n      });\n      const googleUser = GoogleAuth.currentUser.get();\n      setAuthenticated(googleUser.isSignedIn());\n      // console.log(googleUser.getBasicProfile());\n    }\n    script.onload = () => {\n      gapi.load('client:auth2', initClient);\n    }\n\n    const firstScript = document.getElementsByTagName('script')[0];\n    // @ts-ignore\n    firstScript.parentNode.insertBefore(script, firstScript);\n  }, []);\n\n  const signIn = () => {\n    gapi.auth2.getAuthInstance().signIn({\n      prompt: 'select_account',\n    });\n  }\n\n  const signOut = () => {\n    gapi.auth2.getAuthInstance().signOut();\n  }\n\n  return (\n    <GoogleContext.Provider value={{authenticated}}>\n      <Layout style={{background: '#fff'}}>\n        <Content>\n          <div className=\"App\">\n            {!authenticated\n              ? <Button onClick={signIn}>\n                  Sign In\n                </Button>\n              : <Button onClick={signOut}>\n                  Sign out\n                </Button>\n            }\n          </div>\n          <Calendar />\n        </Content>\n      </Layout>\n    </GoogleContext.Provider>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}