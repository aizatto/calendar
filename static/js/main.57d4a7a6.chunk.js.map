{"version":3,"sources":["styles/styles.module.scss","contexts/GoogleContext.tsx","List.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","GoogleContext","React","createContext","authenticated","RangePicker","DatePicker","day","Date","Attendees","props","event","attendees","length","sort","a","b","displayName","email","localeCompare","declined","filter","attendee","responseStatus","attendeesElement","map","style","textDecoration","name","key","id","title","DateTime","start","dateTime","end","startDateTime","endDateTime","dateFns","Intervals","elements","intervals","interval","seconds","getTime","isPast","className","undefined","toISOString","IntervalTime","IntervalBlock","remainingIntervals","remaining","aizattoDateFns","remainingElement","time","hours","Math","floor","minutes","push","join","Event","useState","status","findIndex","self","collapsed","setCollapsed","summary","href","htmlLink","cursor","onClick","hangoutButton","hangoutLink","locationElement","location","styles","description","dangerouslySetInnerHTML","__html","CalendarAuthenticated","timeMin","setTimeMin","timeMax","setTimeMax","events","setEvents","useEffect","async","gapi","client","calendar","list","calendarId","maxResults","orderBy","singleEvents","result","items","eventsFiltered","date","eventsGroupBy","Map","forEach","startDate","endDate","get","has","set","days","Array","from","dateStr","busyIntervals","freeIntervals","eventsElements","paddingBottom","Fragment","defaultValue","moment","onChange","dates","toDate","Calendar","Consumer","Content","Layout","App","setAuthenticated","script","document","createElement","src","defer","initClient","discoveryDocs","scope","init","apiKey","process","REACT_APP_GOOGLE_APP_ID","clientId","GoogleAuth","auth2","getAuthInstance","isSignedIn","listen","signedIn","googleUser","currentUser","onload","load","firstScript","getElementsByTagName","parentNode","insertBefore","Provider","value","background","signOut","signIn","prompt","Boolean","window","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.57d4a7a6.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"description\":\"styles_description__-yQ6f\"};","import React from 'react';\n\nexport const GoogleContext = React.createContext({\n  authenticated: false,\n  // IsSignedInListener: (signedIn: boolean): void => {},\n});","import React, { useState, useEffect } from 'react';\nimport { GoogleContext } from './contexts/GoogleContext';\nimport * as dateFns from 'date-fns';\nimport * as aizattoDateFns from '@aizatto/date-fns';\nimport styles from './styles/styles.module.scss';\nimport { DatePicker } from 'antd';\nimport moment from 'moment';\n\nconst { RangePicker } = DatePicker;\n\nconst day = new Date();\n// const defaultTimeMin = dateFns.startOfDay(day);\n// const defaultTimeMax = dateFns.endOfDay(dateFns.addDays(day, 5));\n\nconst Attendees: React.FC<{event: gapi.client.calendar.Event}> = (props) => {\n  const event = props.event;\n\n  if (!event.attendees || !event.attendees.length) {\n    return <></>;\n  }\n\n  const attendees = event.attendees.sort((a, b) => {\n    if (a.displayName && !b.displayName) {\n      return 1;\n    } else if (!a.displayName && b.displayName) {\n      return -1;\n    }\n\n    return a.email.localeCompare(b.email);\n  });\n\n  const declined = attendees.filter(attendee => attendee.responseStatus === \"declined\");\n\n  const attendeesElement = attendees.map(attendee =>  {\n    const style = attendee.responseStatus === \"declined\"\n      ? {textDecoration: \"line-through\"}  \n      : {};\n\n    const name = attendee.displayName ? attendee.displayName : attendee.email;\n\n    return (\n      <li\n        key={`${event.id}:${attendee.email}`}\n        style={style}\n        title={`${name}: ${attendee.responseStatus}`}>\n        {name}\n      </li>\n    );\n  });\n\n  return (\n    <>\n      Attendees: {attendees.length - declined.length}/{attendees.length}\n      <ol>\n        {attendeesElement}\n      </ol>\n    </>\n  );\n}\n\nconst DateTime: React.FC<{event: gapi.client.calendar.Event}> = (props) => {\n  const event = props.event;\n  if (!event.start.dateTime ||\n      !event.end.dateTime) {\n    return <></>\n  }\n\n  const startDateTime =  new Date(event.start.dateTime);\n  const endDateTime = new Date(event.end.dateTime);\n\n  return (\n    <span title={`${event.start.dateTime} - ${event.end.dateTime}`}>\n      {dateFns.format(startDateTime, 'HH:mm')}\n      {' - '}\n      {dateFns.format(endDateTime, 'HH:mm')}\n    </span>\n  );\n}\n\nconst Intervals: React.FC<{intervals: {start: Date, end: Date}[]}> = (props) => {\n  const elements = props.intervals.map(interval => {\n    const seconds = (interval.end.getTime() - interval.start.getTime()) / 1000;\n\n    const isPast = dateFns.isPast(interval.end);\n\n    const style = isPast\n      ? {textDecoration: \"line-through\"}  \n      : {};\n\n    const className = isPast\n      ? 'text-muted'\n      : undefined;\n\n    return (\n      <li key={interval.start.toISOString()} className={className} style={style}>\n        {dateFns.format(interval.start, 'HH:mm')} - {dateFns.format(interval.end, 'HH:mm')}\n        {': '}\n        {IntervalTime(seconds)}\n      </li>\n    )\n  });\n\n  return (\n    <ol>\n      {elements}\n    </ol>\n  )\n}\n\nconst IntervalBlock: React.FC<{intervals: { start: Date, end: Date }[]}> = (props) => {\n  const intervals = props.intervals;\n  const remainingIntervals = intervals.filter(interval => dateFns.isFuture(interval.end));\n  const remaining = aizattoDateFns.intervalsTotal(remainingIntervals);\n\n  let remainingElement: any = IntervalTime(remaining / 1000);\n\n  if (remainingIntervals.length !== intervals.length){\n    remainingElement = <span className=\"text-muted\">{remainingElement}</span>;\n  }\n\n  const time = remainingElement.length !== 0\n    ?\n      <>\n        {remainingElement}\n        {' / '}\n        {IntervalTime(aizattoDateFns.intervalsTotal(intervals) / 1000)}\n      </>\n    : null;\n\n  return (\n    <>\n    {' '}\n    {time}\n    <Intervals intervals={intervals} />\n    </>\n  );\n}\n\nconst IntervalTime = (seconds: number) => {\n  const hours = Math.floor(seconds / (60 * 60));\n  const minutes = Math.floor(seconds / 60) % 60;\n\n  let time = [];\n\n  if (hours > 1) {\n    time.push(`${hours} hours`)\n  } else if (hours === 1) {\n    time.push(`${hours} hour`)\n  }\n\n  if (minutes > 1) {\n    time.push(`${minutes} minutes`)\n  } else if (minutes === 1) {\n    time.push(`${minutes} minute`)\n  }\n\n  return time.join(' ');\n}\n\nconst Event: React.FC<{event: gapi.client.calendar.Event}> = (props) => {\n  const event = props.event;\n  const [collapsed, setCollapsed] = useState(() => {\n    if (event.status === \"cancelled\") {\n      return true;\n    }\n\n    // @ts-ignore\n    if (dateFns.isPast(new Date(event.end.dateTime))) {\n      return true;\n    }\n\n    return event.attendees?.findIndex(attendee => attendee.self && attendee.responseStatus === \"declined\") !== -1;\n  });\n\n\n  const summary = \n    <>\n      <DateTime event={event} />\n      {' '}\n      <a href={event.htmlLink}>{event.summary}</a>\n    </>;\n\n  if (collapsed) {\n    return (\n      <>\n        <span style={{textDecoration: \"line-through\"}}>\n          {summary}\n        </span>\n        {' '}\n        &middot;\n        {' '}\n        <span className=\"text-muted\" style={{cursor: 'pointer'}} onClick={() => setCollapsed(false)}>\n          Show Details\n        </span>\n      </>\n    )\n  }\n\n  const hangoutButton = event.hangoutLink\n    ? <a href={event.hangoutLink}>Hangout Link</a>\n    : <span style={{textDecoration: 'line-through'}}>Hangout Link</span>\n\n  const locationElement = event.location\n    ? <div>{event.location}</div>\n    : null;\n\n  return (\n    <>\n      <div>\n        {summary}\n      </div>\n      {locationElement}\n\n      <Attendees event={event} />\n\n      <div className={styles.description} dangerouslySetInnerHTML={{__html: event.description}} />\n\n      {hangoutButton}\n    </>\n  );\n}\n\n// const CalendarList: React.FC<{calendars: gapi.client.calendar.CalendarListEntry[]}> = (props) => {\n//   const elements = props.calendars.map((calendar) => {\n//     return (\n//       <li key={calendar.id}>\n//       </li>\n//     )\n//   })\n\n//   return (\n//     <>\n//       <ol>\n//         {elements}\n//       </ol>\n//     </>\n//   );\n// }\n\nexport const CalendarAuthenticated: React.FC = (props) => {\n  const [timeMin, setTimeMin] = useState(() => dateFns.startOfDay(day));\n  const [timeMax, setTimeMax] = useState(() => dateFns.endOfDay(dateFns.addDays(day, 5)));\n\n  // const [calendars, setCalendars] = useState<gapi.client.calendar.CalendarListEntry[]>([]);\n  const [events, setEvents] = useState<gapi.client.calendar.Event[]>([]);\n  useEffect(() => {\n    (async () => {\n      const events = await gapi.client.calendar.events.list({\n        calendarId: 'primary',\n        timeMin: timeMin.toISOString(),\n        timeMax: timeMax.toISOString(),\n        maxResults: 100, \n        orderBy: 'startTime',\n        singleEvents: true,\n      });\n      setEvents(events.result.items);\n\n      // const calendars = await gapi.client.calendar.calendarList.list();\n      // setCalendars(calendars.result.items);\n    })();\n  }, [timeMin, timeMax]);\n\n  const eventsFiltered = events.filter(\n    (event) => {\n      // if (event.status === 'cancelled') {\n      //   return false;\n      // }\n      if (event.end.date) {\n        const endDateTime = dateFns.endOfDay(new Date(event.end.date));\n        return dateFns.isAfter(endDateTime, timeMin);\n      }\n      \n      if (event.end.dateTime &&\n          dateFns.isBefore(new Date(event.end.dateTime), timeMin)) {\n        return false;\n      }\n\n      return true;\n    }\n  );\n\n  /**\n   * lodash.groupBy doesn't work for multi day events\n   */\n  const eventsGroupBy = new Map<string, gapi.client.calendar.Event[]>();\n  // const eventsGroupBy = lodash.groupBy(\n  eventsFiltered.forEach(\n    (event) => {\n      const start = event.start.date ?? event.start.dateTime;\n      const end = event.end.date ?? event.end.dateTime;\n\n      if (!start || !end) {\n        return;\n      }\n\n      const startDate = new Date(start);\n      const endDate = new Date(end);\n      const dates = dateFns.eachDayOfInterval({\n        start: startDate,\n        end: endDate,\n      });\n\n      dates.forEach(date => {\n        const key = date.toISOString();\n        const events = eventsGroupBy.get(key) ?? [];\n        events.push(event);\n        if (!eventsGroupBy.has(key)) {\n          eventsGroupBy.set(key, events);\n        }\n      })\n    });\n  \n  const days = Array.from(eventsGroupBy).map(([dateStr, events]) => {\n    const date = new Date(dateStr);\n    const intervals = events.filter(event => {\n      if (event.status === 'cancelled') {\n        return false;\n      }\n\n      if (!event.start.dateTime || !event.end.dateTime) {\n        return false;\n      }\n\n      return event.attendees?.findIndex(attendee => attendee.self && attendee.responseStatus === \"declined\") === -1;\n    }).map(event => {\n      return {\n        // @ts-ignore\n        start: new Date(event.start.dateTime),\n        // @ts-ignore\n        end: new Date(event.end.dateTime),\n      }\n    });\n\n    const busyIntervals = aizattoDateFns.mergeIntervals(intervals);\n    const freeIntervals = aizattoDateFns.oppositeIntervals(\n      {\n        start: dateFns.startOfDay(date),\n        end: dateFns.endOfDay(date),\n      },\n      busyIntervals,\n    );\n\n    const eventsElements = events.map(event => {\n      return (\n        <li key={event.id} style={{paddingBottom: '1rem'}}>\n          <Event event={event} />\n        </li>\n      );\n    });\n\n    return (\n      <React.Fragment key={dateStr}>\n        <h5>{dateFns.format(date, 'EEEE yyyy-MM-dd')}</h5>\n\n        Busy: \n        <IntervalBlock intervals={busyIntervals} />\n\n        Free: \n        <IntervalBlock intervals={freeIntervals} />\n\n        Schedule: {eventsElements.length} {eventsElements.length > 1 ? 'events' : 'event'}\n        <ol>\n          {eventsElements}\n        </ol>\n      </React.Fragment>\n    );\n  });\n\n  return (\n    <>\n      <a href=\"https://calendar.google.com/\">Google Calendar</a>\n      <div>\n        <RangePicker\n          defaultValue={[moment(timeMin), moment(timeMax)]}\n          onChange={(dates) => {\n            setTimeMin(dates[0]!.toDate());\n            setTimeMax(dates[1]!.toDate());\n          }}\n        />\n      </div>\n      {days}\n    </>\n  )\n}\n\nexport const Calendar: React.FC = (props) => {\n  return (\n    <>\n      <GoogleContext.Consumer>\n        {({authenticated}) => (\n          authenticated \n            ? <CalendarAuthenticated />\n            : <>Not Authenticated</>\n        )}\n      </GoogleContext.Consumer>\n    </>\n  )\n}","import React, { useState, useEffect } from 'react';\nimport './App.css';\nimport { GoogleContext } from './contexts/GoogleContext';\nimport { Calendar } from './List';\n\nimport { Button, Layout } from 'antd';\nconst { Content } = Layout;\n\nconst App: React.FC = () => {\n  const [authenticated, setAuthenticated] = useState(false);\n\n  useEffect(() => {\n    const script = document.createElement('script');\n    script.src = 'https://apis.google.com/js/api.js';\n    script.async = true;\n    script.defer = true;\n\n    const initClient = async () => {\n      const discoveryDocs = [\n        // https://developers.google.com/calendar/quickstart/js\n        \"https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest\"\n      ];\n      const scope = [\n        'https://www.googleapis.com/auth/calendar.events.readonly',\n        'https://www.googleapis.com/auth/calendar.readonly',\n      ].join(' ');\n      await gapi.client.init({\n        discoveryDocs,\n        scope,\n        apiKey: process.env.REACT_APP_GOOGLE_APP_ID,\n        clientId: process.env.REACT_APP_GOOGLE_CLIENT_ID,\n      });\n\n      const GoogleAuth = gapi.auth2.getAuthInstance();\n      GoogleAuth.isSignedIn.listen((signedIn) => {\n        setAuthenticated(signedIn);\n      });\n      const googleUser = GoogleAuth.currentUser.get();\n      setAuthenticated(googleUser.isSignedIn());\n      // console.log(googleUser.getBasicProfile());\n    }\n    script.onload = () => {\n      gapi.load('client:auth2', initClient);\n    }\n\n    const firstScript = document.getElementsByTagName('script')[0];\n    // @ts-ignore\n    firstScript.parentNode.insertBefore(script, firstScript);\n  }, []);\n\n  const signIn = () => {\n    gapi.auth2.getAuthInstance().signIn({\n      prompt: 'select_account',\n    });\n  }\n\n  const signOut = () => {\n    gapi.auth2.getAuthInstance().signOut();\n  }\n\n  return (\n    <GoogleContext.Provider value={{authenticated}}>\n      <Layout style={{background: '#fff'}}>\n        <Content>\n          <div className=\"App\">\n            {!authenticated\n              ? <Button onClick={signIn}>\n                  Sign In\n                </Button>\n              : <Button onClick={signOut}>\n                  Sign out\n                </Button>\n            }\n          </div>\n          <Calendar />\n        </Content>\n      </Layout>\n    </GoogleContext.Provider>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}